/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
impl quote3_error_t {
    #[doc = "< Success"]
    pub const SGX_QL_SUCCESS: quote3_error_t = quote3_error_t(0);
}
impl quote3_error_t {
    #[doc = "< Indicate min error to allow better translation."]
    pub const SGX_QL_ERROR_MIN: quote3_error_t = quote3_error_t(57345);
}
impl quote3_error_t {
    #[doc = "< Unexpected error"]
    pub const SGX_QL_ERROR_UNEXPECTED: quote3_error_t = quote3_error_t(57345);
}
impl quote3_error_t {
    #[doc = "< The parameter is incorrect"]
    pub const SGX_QL_ERROR_INVALID_PARAMETER: quote3_error_t = quote3_error_t(57346);
}
impl quote3_error_t {
    #[doc = "< Not enough memory is available to complete this operation"]
    pub const SGX_QL_ERROR_OUT_OF_MEMORY: quote3_error_t = quote3_error_t(57347);
}
impl quote3_error_t {
    #[doc = "< Expected ECDSA_ID does not match the value stored in the ECDSA Blob"]
    pub const SGX_QL_ERROR_ECDSA_ID_MISMATCH: quote3_error_t = quote3_error_t(57348);
}
impl quote3_error_t {
    #[doc = "< The ECDSA blob pathname is too large"]
    pub const SGX_QL_PATHNAME_BUFFER_OVERFLOW_ERROR: quote3_error_t = quote3_error_t(57349);
}
impl quote3_error_t {
    #[doc = "< Error accessing ECDSA blob"]
    pub const SGX_QL_FILE_ACCESS_ERROR: quote3_error_t = quote3_error_t(57350);
}
impl quote3_error_t {
    #[doc = "< Cached ECDSA key is invalid"]
    pub const SGX_QL_ERROR_STORED_KEY: quote3_error_t = quote3_error_t(57351);
}
impl quote3_error_t {
    #[doc = "< Cached ECDSA key does not match requested key"]
    pub const SGX_QL_ERROR_PUB_KEY_ID_MISMATCH: quote3_error_t = quote3_error_t(57352);
}
impl quote3_error_t {
    #[doc = "< PCE use the incorrect signature scheme"]
    pub const SGX_QL_ERROR_INVALID_PCE_SIG_SCHEME: quote3_error_t = quote3_error_t(57353);
}
impl quote3_error_t {
    #[doc = "< There is a problem with the attestation key blob."]
    pub const SGX_QL_ATT_KEY_BLOB_ERROR: quote3_error_t = quote3_error_t(57354);
}
impl quote3_error_t {
    #[doc = "< Unsupported attestation key ID."]
    pub const SGX_QL_UNSUPPORTED_ATT_KEY_ID: quote3_error_t = quote3_error_t(57355);
}
impl quote3_error_t {
    #[doc = "< Unsupported enclave loading policy."]
    pub const SGX_QL_UNSUPPORTED_LOADING_POLICY: quote3_error_t = quote3_error_t(57356);
}
impl quote3_error_t {
    #[doc = "< Unable to load the PCE enclave"]
    pub const SGX_QL_INTERFACE_UNAVAILABLE: quote3_error_t = quote3_error_t(57357);
}
impl quote3_error_t {
    #[doc = "< Unable to find the platform library with the dependent APIs.  Not fatal."]
    pub const SGX_QL_PLATFORM_LIB_UNAVAILABLE: quote3_error_t = quote3_error_t(57358);
}
impl quote3_error_t {
    #[doc = "< The attestation key doesn't exist or has not been certified."]
    pub const SGX_QL_ATT_KEY_NOT_INITIALIZED: quote3_error_t = quote3_error_t(57359);
}
impl quote3_error_t {
    #[doc = "< The certification data retrieved from the platform library is invalid."]
    pub const SGX_QL_ATT_KEY_CERT_DATA_INVALID: quote3_error_t = quote3_error_t(57360);
}
impl quote3_error_t {
    #[doc = "< The platform library doesn't have any platfrom cert data."]
    pub const SGX_QL_NO_PLATFORM_CERT_DATA: quote3_error_t = quote3_error_t(57361);
}
impl quote3_error_t {
    #[doc = "< Not enough memory in the EPC to load the enclave."]
    pub const SGX_QL_OUT_OF_EPC: quote3_error_t = quote3_error_t(57362);
}
impl quote3_error_t {
    #[doc = "< There was a problem verifying an SGX REPORT."]
    pub const SGX_QL_ERROR_REPORT: quote3_error_t = quote3_error_t(57363);
}
impl quote3_error_t {
    #[doc = "< Interfacing to the enclave failed due to a power transition."]
    pub const SGX_QL_ENCLAVE_LOST: quote3_error_t = quote3_error_t(57364);
}
impl quote3_error_t {
    #[doc = "< Error verifying the application enclave's report."]
    pub const SGX_QL_INVALID_REPORT: quote3_error_t = quote3_error_t(57365);
}
impl quote3_error_t {
    #[doc = "< Unable to load the enclaves. Could be due to file I/O error, loading infrastructure error, or non-SGX capable system"]
    pub const SGX_QL_ENCLAVE_LOAD_ERROR: quote3_error_t = quote3_error_t(57366);
}
impl quote3_error_t {
    #[doc = "< The QE was unable to generate its own report targeting the application enclave either\n< because the QE doesn't support this feature there is an enclave compatibility issue.\n< Please call again with the p_qe_report_info to NULL."]
    pub const SGX_QL_UNABLE_TO_GENERATE_QE_REPORT: quote3_error_t = quote3_error_t(57367);
}
impl quote3_error_t {
    #[doc = "< Caused when the provider library returns an invalid TCB (too high)."]
    pub const SGX_QL_KEY_CERTIFCATION_ERROR: quote3_error_t = quote3_error_t(57368);
}
impl quote3_error_t {
    #[doc = "< Network error when retrieving PCK certs"]
    pub const SGX_QL_NETWORK_ERROR: quote3_error_t = quote3_error_t(57369);
}
impl quote3_error_t {
    #[doc = "< Message error when retrieving PCK certs"]
    pub const SGX_QL_MESSAGE_ERROR: quote3_error_t = quote3_error_t(57370);
}
impl quote3_error_t {
    #[doc = "< The platform does not have the quote verification collateral data available."]
    pub const SGX_QL_NO_QUOTE_COLLATERAL_DATA: quote3_error_t = quote3_error_t(57371);
}
impl quote3_error_t {
    pub const SGX_QL_QUOTE_CERTIFICATION_DATA_UNSUPPORTED: quote3_error_t = quote3_error_t(57372);
}
impl quote3_error_t {
    pub const SGX_QL_QUOTE_FORMAT_UNSUPPORTED: quote3_error_t = quote3_error_t(57373);
}
impl quote3_error_t {
    pub const SGX_QL_UNABLE_TO_GENERATE_REPORT: quote3_error_t = quote3_error_t(57374);
}
impl quote3_error_t {
    pub const SGX_QL_QE_REPORT_INVALID_SIGNATURE: quote3_error_t = quote3_error_t(57375);
}
impl quote3_error_t {
    pub const SGX_QL_QE_REPORT_UNSUPPORTED_FORMAT: quote3_error_t = quote3_error_t(57376);
}
impl quote3_error_t {
    pub const SGX_QL_PCK_CERT_UNSUPPORTED_FORMAT: quote3_error_t = quote3_error_t(57377);
}
impl quote3_error_t {
    pub const SGX_QL_PCK_CERT_CHAIN_ERROR: quote3_error_t = quote3_error_t(57378);
}
impl quote3_error_t {
    pub const SGX_QL_TCBINFO_UNSUPPORTED_FORMAT: quote3_error_t = quote3_error_t(57379);
}
impl quote3_error_t {
    pub const SGX_QL_TCBINFO_MISMATCH: quote3_error_t = quote3_error_t(57380);
}
impl quote3_error_t {
    pub const SGX_QL_QEIDENTITY_UNSUPPORTED_FORMAT: quote3_error_t = quote3_error_t(57381);
}
impl quote3_error_t {
    pub const SGX_QL_QEIDENTITY_MISMATCH: quote3_error_t = quote3_error_t(57382);
}
impl quote3_error_t {
    pub const SGX_QL_TCB_OUT_OF_DATE: quote3_error_t = quote3_error_t(57383);
}
impl quote3_error_t {
    #[doc = "< TCB out of date and Configuration needed"]
    pub const SGX_QL_TCB_OUT_OF_DATE_CONFIGURATION_NEEDED: quote3_error_t = quote3_error_t(57384);
}
impl quote3_error_t {
    pub const SGX_QL_SGX_ENCLAVE_IDENTITY_OUT_OF_DATE: quote3_error_t = quote3_error_t(57385);
}
impl quote3_error_t {
    pub const SGX_QL_SGX_ENCLAVE_REPORT_ISVSVN_OUT_OF_DATE: quote3_error_t = quote3_error_t(57386);
}
impl quote3_error_t {
    pub const SGX_QL_QE_IDENTITY_OUT_OF_DATE: quote3_error_t = quote3_error_t(57387);
}
impl quote3_error_t {
    pub const SGX_QL_SGX_TCB_INFO_EXPIRED: quote3_error_t = quote3_error_t(57388);
}
impl quote3_error_t {
    pub const SGX_QL_SGX_PCK_CERT_CHAIN_EXPIRED: quote3_error_t = quote3_error_t(57389);
}
impl quote3_error_t {
    pub const SGX_QL_SGX_CRL_EXPIRED: quote3_error_t = quote3_error_t(57390);
}
impl quote3_error_t {
    pub const SGX_QL_SGX_SIGNING_CERT_CHAIN_EXPIRED: quote3_error_t = quote3_error_t(57391);
}
impl quote3_error_t {
    pub const SGX_QL_SGX_ENCLAVE_IDENTITY_EXPIRED: quote3_error_t = quote3_error_t(57392);
}
impl quote3_error_t {
    pub const SGX_QL_PCK_REVOKED: quote3_error_t = quote3_error_t(57393);
}
impl quote3_error_t {
    pub const SGX_QL_TCB_REVOKED: quote3_error_t = quote3_error_t(57394);
}
impl quote3_error_t {
    pub const SGX_QL_TCB_CONFIGURATION_NEEDED: quote3_error_t = quote3_error_t(57395);
}
impl quote3_error_t {
    pub const SGX_QL_UNABLE_TO_GET_COLLATERAL: quote3_error_t = quote3_error_t(57396);
}
impl quote3_error_t {
    #[doc = "< No enough privilege to perform the operation"]
    pub const SGX_QL_ERROR_INVALID_PRIVILEGE: quote3_error_t = quote3_error_t(57397);
}
impl quote3_error_t {
    #[doc = "< The platform does not have the QVE identity data available."]
    pub const SGX_QL_NO_QVE_IDENTITY_DATA: quote3_error_t = quote3_error_t(57399);
}
impl quote3_error_t {
    pub const SGX_QL_CRL_UNSUPPORTED_FORMAT: quote3_error_t = quote3_error_t(57400);
}
impl quote3_error_t {
    pub const SGX_QL_QEIDENTITY_CHAIN_ERROR: quote3_error_t = quote3_error_t(57401);
}
impl quote3_error_t {
    pub const SGX_QL_TCBINFO_CHAIN_ERROR: quote3_error_t = quote3_error_t(57402);
}
impl quote3_error_t {
    #[doc = "< Supplemental data size and version mismatched between QVL and QvE\n< Please make sure to use QVL and QvE from same release package"]
    pub const SGX_QL_ERROR_QVL_QVE_MISMATCH: quote3_error_t = quote3_error_t(57403);
}
impl quote3_error_t {
    #[doc = "< TCB up to date but SW Hardening needed"]
    pub const SGX_QL_TCB_SW_HARDENING_NEEDED: quote3_error_t = quote3_error_t(57404);
}
impl quote3_error_t {
    #[doc = "< TCB up to date but Configuration and SW Hardening needed"]
    pub const SGX_QL_TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED: quote3_error_t =
        quote3_error_t(57405);
}
impl quote3_error_t {
    pub const SGX_QL_UNSUPPORTED_MODE: quote3_error_t = quote3_error_t(57406);
}
impl quote3_error_t {
    pub const SGX_QL_NO_DEVICE: quote3_error_t = quote3_error_t(57407);
}
impl quote3_error_t {
    pub const SGX_QL_SERVICE_UNAVAILABLE: quote3_error_t = quote3_error_t(57408);
}
impl quote3_error_t {
    pub const SGX_QL_NETWORK_FAILURE: quote3_error_t = quote3_error_t(57409);
}
impl quote3_error_t {
    pub const SGX_QL_SERVICE_TIMEOUT: quote3_error_t = quote3_error_t(57410);
}
impl quote3_error_t {
    pub const SGX_QL_ERROR_BUSY: quote3_error_t = quote3_error_t(57411);
}
impl quote3_error_t {
    pub const SGX_QL_UNKNOWN_MESSAGE_RESPONSE: quote3_error_t = quote3_error_t(57412);
}
impl quote3_error_t {
    #[doc = " Unexpected error from the cache service"]
    pub const SGX_QL_PERSISTENT_STORAGE_ERROR: quote3_error_t = quote3_error_t(57413);
}
impl quote3_error_t {
    #[doc = " Error storing the retrieved cached data in persistent memory"]
    pub const SGX_QL_ERROR_MESSAGE_PARSING_ERROR: quote3_error_t = quote3_error_t(57414);
}
impl quote3_error_t {
    #[doc = " Message parsing error"]
    pub const SGX_QL_PLATFORM_UNKNOWN: quote3_error_t = quote3_error_t(57415);
}
impl quote3_error_t {
    #[doc = " Platform was not found in the cache"]
    pub const SGX_QL_UNKNOWN_API_VERSION: quote3_error_t = quote3_error_t(57416);
}
impl quote3_error_t {
    #[doc = " The current PCS API version configured is unknown"]
    pub const SGX_QL_CERTS_UNAVAILABLE: quote3_error_t = quote3_error_t(57417);
}
impl quote3_error_t {
    #[doc = "< QvE Identity is NOT match to Intel signed QvE identity"]
    pub const SGX_QL_QVEIDENTITY_MISMATCH: quote3_error_t = quote3_error_t(57424);
}
impl quote3_error_t {
    #[doc = "< QvE ISVSVN is smaller than the ISVSVN threshold, or input QvE ISVSVN is too small"]
    pub const SGX_QL_QVE_OUT_OF_DATE: quote3_error_t = quote3_error_t(57425);
}
impl quote3_error_t {
    #[doc = "< SGX PSW library cannot be loaded, could be due to file I/O error"]
    pub const SGX_QL_PSW_NOT_AVAILABLE: quote3_error_t = quote3_error_t(57426);
}
impl quote3_error_t {
    #[doc = "< SGX quote verification collateral version not supported by QVL/QvE"]
    pub const SGX_QL_COLLATERAL_VERSION_NOT_SUPPORTED: quote3_error_t = quote3_error_t(57427);
}
impl quote3_error_t {
    #[doc = "< TDX SEAM module identity is NOT match to Intel signed TDX SEAM module"]
    pub const SGX_QL_TDX_MODULE_MISMATCH: quote3_error_t = quote3_error_t(57440);
}
impl quote3_error_t {
    #[doc = "< QE identity was not found"]
    pub const SGX_QL_QEIDENTITY_NOT_FOUND: quote3_error_t = quote3_error_t(57441);
}
impl quote3_error_t {
    #[doc = "< TCB Info was not found"]
    pub const SGX_QL_TCBINFO_NOT_FOUND: quote3_error_t = quote3_error_t(57442);
}
impl quote3_error_t {
    #[doc = "< Internal server error"]
    pub const SGX_QL_INTERNAL_SERVER_ERROR: quote3_error_t = quote3_error_t(57443);
}
impl quote3_error_t {
    #[doc = "< The supplemental data version is not supported"]
    pub const SGX_QL_SUPPLEMENTAL_DATA_VERSION_NOT_SUPPORTED: quote3_error_t =
        quote3_error_t(57444);
}
impl quote3_error_t {
    #[doc = "< The certificate used to establish SSL session is untrusted"]
    pub const SGX_QL_ROOT_CA_UNTRUSTED: quote3_error_t = quote3_error_t(57445);
}
impl quote3_error_t {
    #[doc = "< Current TCB level cannot be found in platform/enclave TCB info"]
    pub const SGX_QL_TCB_NOT_SUPPORTED: quote3_error_t = quote3_error_t(57446);
}
impl quote3_error_t {
    #[doc = "< The QPL's config file is in JSON format but has a format error"]
    pub const SGX_QL_CONFIG_INVALID_JSON: quote3_error_t = quote3_error_t(57447);
}
impl quote3_error_t {
    #[doc = "< Invalid signature during quote verification"]
    pub const SGX_QL_RESULT_INVALID_SIGNATURE: quote3_error_t = quote3_error_t(57448);
}
impl quote3_error_t {
    #[doc = "< Indicate max error to allow better translation."]
    pub const SGX_QL_ERROR_MAX: quote3_error_t = quote3_error_t(57599);
}
#[repr(transparent)]
#[doc = " Possible errors generated by the quote interface."]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct quote3_error_t(pub core::ffi::c_uint);
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_qe3_id_t {
    #[doc = "< Contains the 16-byte QE_ID"]
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sgx_ql_qe3_id_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_qe3_id_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_qe3_id_t>(),
        16usize,
        concat!("Size of: ", stringify!(sgx_ql_qe3_id_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_qe3_id_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_qe3_id_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qe3_id_t),
            "::",
            stringify!(id)
        )
    );
}
#[doc = " Used to describe the PCK Cert for a platform"]
#[repr(C, packed)]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_pck_cert_id_t {
    #[doc = "< The QE_ID used to identify the platform for PCK Cert Retrieval"]
    pub p_qe3_id: *mut u8,
    #[doc = "< The Size of hte QE_ID (currenlty 16 bytes)"]
    pub qe3_id_size: u32,
    #[doc = "< Pointer to the platform's raw CPUSVN"]
    pub p_platform_cpu_svn: *mut sgx_cpu_svn_t,
    #[doc = "< Pointer to the platform's raw PCE ISVSVN"]
    pub p_platform_pce_isv_svn: *mut sgx_isv_svn_t,
    #[doc = "< Pointer to the encrypted PPID (Optional)"]
    pub p_encrypted_ppid: *mut u8,
    #[doc = "< Size of encrytped PPID."]
    pub encrypted_ppid_size: u32,
    #[doc = "< Crypto algorithm used to encrypt the PPID"]
    pub crypto_suite: u8,
    #[doc = "< Identifies the PCE-Version used to generate the encrypted PPID."]
    pub pce_id: u16,
}
#[test]
fn bindgen_test_layout_sgx_ql_pck_cert_id_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_pck_cert_id_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_pck_cert_id_t>(),
        43usize,
        concat!("Size of: ", stringify!(sgx_ql_pck_cert_id_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_pck_cert_id_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_pck_cert_id_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_qe3_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_pck_cert_id_t),
            "::",
            stringify!(p_qe3_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe3_id_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_pck_cert_id_t),
            "::",
            stringify!(qe3_id_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_platform_cpu_svn) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_pck_cert_id_t),
            "::",
            stringify!(p_platform_cpu_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_platform_pce_isv_svn) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_pck_cert_id_t),
            "::",
            stringify!(p_platform_pce_isv_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_encrypted_ppid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_pck_cert_id_t),
            "::",
            stringify!(p_encrypted_ppid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrypted_ppid_size) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_pck_cert_id_t),
            "::",
            stringify!(encrypted_ppid_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crypto_suite) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_pck_cert_id_t),
            "::",
            stringify!(crypto_suite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pce_id) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_pck_cert_id_t),
            "::",
            stringify!(pce_id)
        )
    );
}
impl sgx_ql_config_version_t {
    pub const SGX_QL_CONFIG_VERSION_1: sgx_ql_config_version_t = sgx_ql_config_version_t(1);
}
#[repr(transparent)]
#[doc = " Contains the valid versions of the sgx_ql_config_t data structure."]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct sgx_ql_config_version_t(pub core::ffi::c_uint);
#[doc = " Contains the certification data used to certify the attestation key and in generating a quote."]
#[repr(C, packed)]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_config_t {
    pub version: sgx_ql_config_version_t,
    #[doc = "< The CPUSVN used to generate the PCK Signature used to certify the attestation key."]
    pub cert_cpu_svn: sgx_cpu_svn_t,
    #[doc = "< The PCE ISVSVN used to generate the PCK Signature used to certify the attestation key."]
    pub cert_pce_isv_svn: sgx_isv_svn_t,
    #[doc = "< The size of the buffer pointed to by p_cert_data"]
    pub cert_data_size: u32,
    #[doc = "< The certification data used for the quote."]
    pub p_cert_data: *mut u8,
}
#[test]
fn bindgen_test_layout_sgx_ql_config_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_config_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_config_t>(),
        34usize,
        concat!("Size of: ", stringify!(sgx_ql_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_config_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_config_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_config_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cert_cpu_svn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_config_t),
            "::",
            stringify!(cert_cpu_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cert_pce_isv_svn) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_config_t),
            "::",
            stringify!(cert_pce_isv_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cert_data_size) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_config_t),
            "::",
            stringify!(cert_data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_cert_data) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_config_t),
            "::",
            stringify!(p_cert_data)
        )
    );
}
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_qve_collateral_param_t {
    pub key: [u8; 257usize],
    pub value: [u8; 257usize],
}
#[test]
fn bindgen_test_layout_sgx_ql_qve_collateral_param_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_qve_collateral_param_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_qve_collateral_param_t>(),
        514usize,
        concat!("Size of: ", stringify!(sgx_ql_qve_collateral_param_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_qve_collateral_param_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_qve_collateral_param_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_param_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        257usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_param_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_qve_collateral_t {
    pub __bindgen_anon_1: sgx_ql_qve_collateral_t__bindgen_ty_1_t,
    #[doc = "<  0x00000000: SGX or 0x00000081: TDX"]
    pub tee_type: u32,
    pub pck_crl_issuer_chain: *mut core::ffi::c_char,
    pub pck_crl_issuer_chain_size: u32,
    pub root_ca_crl: *mut core::ffi::c_char,
    #[doc = " Root CA CRL"]
    pub root_ca_crl_size: u32,
    pub pck_crl: *mut core::ffi::c_char,
    #[doc = " PCK Cert CRL"]
    pub pck_crl_size: u32,
    pub tcb_info_issuer_chain: *mut core::ffi::c_char,
    pub tcb_info_issuer_chain_size: u32,
    pub tcb_info: *mut core::ffi::c_char,
    #[doc = " TCB Info structure"]
    pub tcb_info_size: u32,
    pub qe_identity_issuer_chain: *mut core::ffi::c_char,
    pub qe_identity_issuer_chain_size: u32,
    pub qe_identity: *mut core::ffi::c_char,
    #[doc = " QE Identity Structure"]
    pub qe_identity_size: u32,
}
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_qve_collateral_t__bindgen_ty_1_t {
    #[doc = "< 'version' is the backward compatible legacy representation"]
    pub version: __BindgenUnionField<u32>,
    pub __bindgen_anon_1:
        __BindgenUnionField<sgx_ql_qve_collateral_t__bindgen_ty_1__bindgen_ty_1_t>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_qve_collateral_t__bindgen_ty_1__bindgen_ty_1_t {
    #[doc = "< the CRLs will be formatted in PEM. For PCS V3 APIs, the major_version = 3 and the"]
    pub major_version: u16,
    #[doc = "< minor_version can be either 0 or 1. minor_verion of 0 indicates the CRL’s are formatted\n< in Base16 encoded DER.  A minor version of 1 indicates the CRL’s are formatted in raw binary DER."]
    pub minor_version: u16,
}
#[test]
fn bindgen_test_layout_sgx_ql_qve_collateral_t__bindgen_ty_1__bindgen_ty_1_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_qve_collateral_t__bindgen_ty_1__bindgen_ty_1_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_qve_collateral_t__bindgen_ty_1__bindgen_ty_1_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sgx_ql_qve_collateral_t__bindgen_ty_1__bindgen_ty_1_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_qve_collateral_t__bindgen_ty_1__bindgen_ty_1_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(sgx_ql_qve_collateral_t__bindgen_ty_1__bindgen_ty_1_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).major_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t__bindgen_ty_1__bindgen_ty_1_t),
            "::",
            stringify!(major_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor_version) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t__bindgen_ty_1__bindgen_ty_1_t),
            "::",
            stringify!(minor_version)
        )
    );
}
#[test]
fn bindgen_test_layout_sgx_ql_qve_collateral_t__bindgen_ty_1_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_qve_collateral_t__bindgen_ty_1_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_qve_collateral_t__bindgen_ty_1_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sgx_ql_qve_collateral_t__bindgen_ty_1_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_qve_collateral_t__bindgen_ty_1_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(sgx_ql_qve_collateral_t__bindgen_ty_1_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t__bindgen_ty_1_t),
            "::",
            stringify!(version)
        )
    );
}
#[test]
fn bindgen_test_layout_sgx_ql_qve_collateral_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_qve_collateral_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_qve_collateral_t>(),
        120usize,
        concat!("Size of: ", stringify!(sgx_ql_qve_collateral_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_qve_collateral_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sgx_ql_qve_collateral_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tee_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(tee_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pck_crl_issuer_chain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(pck_crl_issuer_chain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pck_crl_issuer_chain_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(pck_crl_issuer_chain_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root_ca_crl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(root_ca_crl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root_ca_crl_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(root_ca_crl_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pck_crl) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(pck_crl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pck_crl_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(pck_crl_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcb_info_issuer_chain) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(tcb_info_issuer_chain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcb_info_issuer_chain_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(tcb_info_issuer_chain_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcb_info) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(tcb_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcb_info_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(tcb_info_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_identity_issuer_chain) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(qe_identity_issuer_chain)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).qe_identity_issuer_chain_size) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(qe_identity_issuer_chain_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_identity) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(qe_identity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_identity_size) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qve_collateral_t),
            "::",
            stringify!(qe_identity_size)
        )
    );
}
impl sgx_ql_log_level_t {
    pub const SGX_QL_LOG_ERROR: sgx_ql_log_level_t = sgx_ql_log_level_t(0);
}
impl sgx_ql_log_level_t {
    pub const SGX_QL_LOG_INFO: sgx_ql_log_level_t = sgx_ql_log_level_t(1);
}
impl sgx_ql_log_level_t {
    pub const SGX_QL_LOG_DEBUG: sgx_ql_log_level_t = sgx_ql_log_level_t(2);
}
impl sgx_ql_log_level_t {
    pub const SGX_QL_LOG_TRACE: sgx_ql_log_level_t = sgx_ql_log_level_t(3);
}
#[repr(transparent)]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct sgx_ql_log_level_t(pub core::ffi::c_uint);
pub type sgx_ql_logging_callback_t = ::core::option::Option<
    unsafe extern "C" fn(level: sgx_ql_log_level_t, message: *const core::ffi::c_char),
>;
impl sgx_prod_type_t {
    pub const SGX_PROD_TYPE_SGX: sgx_prod_type_t = sgx_prod_type_t(0);
}
impl sgx_prod_type_t {
    pub const SGX_PROD_TYPE_TDX: sgx_prod_type_t = sgx_prod_type_t(1);
}
#[repr(transparent)]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct sgx_prod_type_t(pub core::ffi::c_uint);
impl sgx_pce_error_t {
    pub const SGX_PCE_SUCCESS: sgx_pce_error_t = sgx_pce_error_t(61440);
}
impl sgx_pce_error_t {
    pub const SGX_PCE_UNEXPECTED: sgx_pce_error_t = sgx_pce_error_t(61441);
}
impl sgx_pce_error_t {
    pub const SGX_PCE_INVALID_PARAMETER: sgx_pce_error_t = sgx_pce_error_t(61442);
}
impl sgx_pce_error_t {
    pub const SGX_PCE_OUT_OF_EPC: sgx_pce_error_t = sgx_pce_error_t(61443);
}
impl sgx_pce_error_t {
    pub const SGX_PCE_INTERFACE_UNAVAILABLE: sgx_pce_error_t = sgx_pce_error_t(61444);
}
impl sgx_pce_error_t {
    pub const SGX_PCE_INVALID_REPORT: sgx_pce_error_t = sgx_pce_error_t(61445);
}
impl sgx_pce_error_t {
    pub const SGX_PCE_CRYPTO_ERROR: sgx_pce_error_t = sgx_pce_error_t(61446);
}
impl sgx_pce_error_t {
    pub const SGX_PCE_INVALID_PRIVILEGE: sgx_pce_error_t = sgx_pce_error_t(61447);
}
impl sgx_pce_error_t {
    pub const SGX_PCE_INVALID_TCB: sgx_pce_error_t = sgx_pce_error_t(61448);
}
#[repr(transparent)]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct sgx_pce_error_t(pub core::ffi::c_uint);
impl sgx_ql_request_policy_t {
    #[doc = "< QE is initialized on first use and reused until process ends."]
    pub const SGX_QL_PERSISTENT: sgx_ql_request_policy_t = sgx_ql_request_policy_t(0);
}
impl sgx_ql_request_policy_t {
    #[doc = "< QE is initialized and terminated on every quote.\n< If a previous QE exists, it is stopped & restarted before quoting."]
    pub const SGX_QL_EPHEMERAL: sgx_ql_request_policy_t = sgx_ql_request_policy_t(1);
}
impl sgx_ql_request_policy_t {
    #[doc = "< Only used for quote verification, QvE is loaded per thread and be unloaded before function exit."]
    pub const SGX_QL_EPHEMERAL_QVE_MULTI_THREAD: sgx_ql_request_policy_t =
        sgx_ql_request_policy_t(2);
}
impl sgx_ql_request_policy_t {
    #[doc = "< Only used for quote verification, QvE is loaded per thread and be unloaded before thread exit."]
    pub const SGX_QL_PERSISTENT_QVE_MULTI_THREAD: sgx_ql_request_policy_t =
        sgx_ql_request_policy_t(3);
}
impl sgx_ql_request_policy_t {
    pub const SGX_QL_DEFAULT: sgx_ql_request_policy_t = sgx_ql_request_policy_t(0);
}
#[repr(transparent)]
#[doc = " Typedef enum _sgx_ql_request_policy"]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct sgx_ql_request_policy_t(pub core::ffi::c_uint);
#[doc = " Structure for the Platform Certificate Enclave identity information"]
#[repr(C, packed)]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct sgx_pce_info_t {
    #[doc = "< PCE ISVSVN"]
    pub pce_isv_svn: sgx_isv_svn_t,
    #[doc = "< PCE ID.  It will change when something in the PCE would cause the PPID generation to change on the same platform"]
    pub pce_id: u16,
}
#[test]
fn bindgen_test_layout_sgx_pce_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_pce_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_pce_info_t>(),
        4usize,
        concat!("Size of: ", stringify!(sgx_pce_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_pce_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_pce_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pce_isv_svn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_pce_info_t),
            "::",
            stringify!(pce_isv_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pce_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_pce_info_t),
            "::",
            stringify!(pce_id)
        )
    );
}
impl sgx_ql_attestation_algorithm_id_t {
    #[doc = "< EPID 2.0 - Anonymous"]
    pub const SGX_QL_ALG_EPID: sgx_ql_attestation_algorithm_id_t =
        sgx_ql_attestation_algorithm_id_t(0);
}
impl sgx_ql_attestation_algorithm_id_t {
    #[doc = "< Reserved"]
    pub const SGX_QL_ALG_RESERVED_1: sgx_ql_attestation_algorithm_id_t =
        sgx_ql_attestation_algorithm_id_t(1);
}
impl sgx_ql_attestation_algorithm_id_t {
    #[doc = "< ECDSA-256-with-P-256 curve, Non - Anonymous"]
    pub const SGX_QL_ALG_ECDSA_P256: sgx_ql_attestation_algorithm_id_t =
        sgx_ql_attestation_algorithm_id_t(2);
}
impl sgx_ql_attestation_algorithm_id_t {
    #[doc = "< ECDSA-384-with-P-384 curve (Note: currently not supported), Non-Anonymous"]
    pub const SGX_QL_ALG_ECDSA_P384: sgx_ql_attestation_algorithm_id_t =
        sgx_ql_attestation_algorithm_id_t(3);
}
impl sgx_ql_attestation_algorithm_id_t {
    pub const SGX_QL_ALG_MAX: sgx_ql_attestation_algorithm_id_t =
        sgx_ql_attestation_algorithm_id_t(4);
}
#[repr(transparent)]
#[doc = " Enumerates the different attestation key algorithms"]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct sgx_ql_attestation_algorithm_id_t(pub core::ffi::c_uint);
impl sgx_ql_cert_key_type_t {
    #[doc = "< Clear PPID + CPU_SVN, PvE_SVN, PCE_SVN, PCE_ID"]
    pub const PPID_CLEARTEXT: sgx_ql_cert_key_type_t = sgx_ql_cert_key_type_t(1);
}
impl sgx_ql_cert_key_type_t {
    #[doc = "< RSA-2048-OAEP Encrypted PPID + CPU_SVN, PvE_SVN, PCE_SVN, PCE_ID"]
    pub const PPID_RSA2048_ENCRYPTED: sgx_ql_cert_key_type_t = sgx_ql_cert_key_type_t(2);
}
impl sgx_ql_cert_key_type_t {
    #[doc = "< RSA-3072-OAEP Encrypted PPID + CPU_SVN, PvE_SVN, PCE_SVN, PCE_ID"]
    pub const PPID_RSA3072_ENCRYPTED: sgx_ql_cert_key_type_t = sgx_ql_cert_key_type_t(3);
}
impl sgx_ql_cert_key_type_t {
    #[doc = "< Clear PCK Leaf Cert"]
    pub const PCK_CLEARTEXT: sgx_ql_cert_key_type_t = sgx_ql_cert_key_type_t(4);
}
impl sgx_ql_cert_key_type_t {
    #[doc = "< Full PCK Cert chain (PCK Leaf Cert|| Intermediate CA Cert || Root CA Cert)"]
    pub const PCK_CERT_CHAIN: sgx_ql_cert_key_type_t = sgx_ql_cert_key_type_t(5);
}
impl sgx_ql_cert_key_type_t {
    #[doc = "< Indicates the contents of the CERTIFICATION_INFO_DATA contains the ECDSA_SIG_AUX_DATA of another Quote."]
    pub const ECDSA_SIG_AUX_DATA: sgx_ql_cert_key_type_t = sgx_ql_cert_key_type_t(6);
}
impl sgx_ql_cert_key_type_t {
    pub const QL_CERT_KEY_TYPE_MAX: sgx_ql_cert_key_type_t = sgx_ql_cert_key_type_t(16);
}
#[repr(transparent)]
#[doc = " Enumerates the different certification data types used to describe the signer of the attestation key"]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct sgx_ql_cert_key_type_t(pub core::ffi::c_uint);
#[doc = " Describes the header that contains the list of attestation keys supported by a given verifier"]
#[repr(C, packed)]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_att_key_id_list_header_t {
    #[doc = "< Structure ID"]
    pub id: u16,
    #[doc = "< Structure version"]
    pub version: u16,
    #[doc = "< Number of 'Attestation Key Identifier' Elements"]
    pub num_att_ids: u32,
}
#[test]
fn bindgen_test_layout_sgx_ql_att_key_id_list_header_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_att_key_id_list_header_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_att_key_id_list_header_t>(),
        8usize,
        concat!("Size of: ", stringify!(sgx_ql_att_key_id_list_header_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_att_key_id_list_header_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_att_key_id_list_header_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_list_header_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_list_header_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_att_ids) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_list_header_t),
            "::",
            stringify!(num_att_ids)
        )
    );
}
#[doc = " This is the data structure of the CERTIFICATION_INFO_DATA in the Quote when the certification type is\n  PPID_CLEARTTEXT. It identifies the PCK Cert required to verify the certification signature."]
#[repr(C)]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_ppid_cleartext_cert_info_t {
    #[doc = "< PPID of this platform"]
    pub ppid: [u8; 16usize],
    #[doc = "< The CPUSVN TCB used to generate the PCK signature."]
    pub cpu_svn: sgx_cpu_svn_t,
    #[doc = "< The PCE ISVSVN used to generate the PCK signature."]
    pub pce_info: sgx_pce_info_t,
}
#[test]
fn bindgen_test_layout_sgx_ql_ppid_cleartext_cert_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_ppid_cleartext_cert_info_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_ppid_cleartext_cert_info_t>(),
        36usize,
        concat!("Size of: ", stringify!(sgx_ql_ppid_cleartext_cert_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_ppid_cleartext_cert_info_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sgx_ql_ppid_cleartext_cert_info_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ppid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ppid_cleartext_cert_info_t),
            "::",
            stringify!(ppid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_svn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ppid_cleartext_cert_info_t),
            "::",
            stringify!(cpu_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pce_info) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ppid_cleartext_cert_info_t),
            "::",
            stringify!(pce_info)
        )
    );
}
#[doc = " This is the data structure of the CERTIFICATION_INFO_DATA in the Quote when the certification type is\n  PPID_RSA2048_ENCRYPTED. It identifies the PCK Cert required to verify the certification signature."]
#[repr(C)]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_ppid_rsa2048_encrypted_cert_info_t {
    #[doc = "< Encrypted PPID of this platform"]
    pub enc_ppid: [u8; 256usize],
    #[doc = "< The CPUSVN TCB used to generate the PCK signature."]
    pub cpu_svn: sgx_cpu_svn_t,
    #[doc = "< The PCE ISVSVN used to generate the PCK signature."]
    pub pce_info: sgx_pce_info_t,
}
#[test]
fn bindgen_test_layout_sgx_ql_ppid_rsa2048_encrypted_cert_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_ppid_rsa2048_encrypted_cert_info_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_ppid_rsa2048_encrypted_cert_info_t>(),
        276usize,
        concat!(
            "Size of: ",
            stringify!(sgx_ql_ppid_rsa2048_encrypted_cert_info_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_ppid_rsa2048_encrypted_cert_info_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sgx_ql_ppid_rsa2048_encrypted_cert_info_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enc_ppid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ppid_rsa2048_encrypted_cert_info_t),
            "::",
            stringify!(enc_ppid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_svn) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ppid_rsa2048_encrypted_cert_info_t),
            "::",
            stringify!(cpu_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pce_info) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ppid_rsa2048_encrypted_cert_info_t),
            "::",
            stringify!(pce_info)
        )
    );
}
#[doc = " This is the data structure of the CERTIFICATION_INFO_DATA in the Quote when the certification type is\n  PPID_RSA2072_ENCRYPTED. It identifies the PCK Cert required to verify the certification signature."]
#[repr(C)]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_ppid_rsa3072_encrypted_cert_info_t {
    #[doc = "< Encrypted PPID of this platform"]
    pub enc_ppid: [u8; 384usize],
    #[doc = "< The CPUSVN TCB used to generate the PCK signature."]
    pub cpu_svn: sgx_cpu_svn_t,
    #[doc = "< The PCE ISVSVN used to generate the PCK signature."]
    pub pce_info: sgx_pce_info_t,
}
#[test]
fn bindgen_test_layout_sgx_ql_ppid_rsa3072_encrypted_cert_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_ppid_rsa3072_encrypted_cert_info_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_ppid_rsa3072_encrypted_cert_info_t>(),
        404usize,
        concat!(
            "Size of: ",
            stringify!(sgx_ql_ppid_rsa3072_encrypted_cert_info_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_ppid_rsa3072_encrypted_cert_info_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sgx_ql_ppid_rsa3072_encrypted_cert_info_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enc_ppid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ppid_rsa3072_encrypted_cert_info_t),
            "::",
            stringify!(enc_ppid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_svn) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ppid_rsa3072_encrypted_cert_info_t),
            "::",
            stringify!(cpu_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pce_info) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ppid_rsa3072_encrypted_cert_info_t),
            "::",
            stringify!(pce_info)
        )
    );
}
#[doc = " Structure to hold the size of the authentication data and the place holder for\nthe authentication data itself."]
#[repr(C, packed)]
pub struct sgx_ql_auth_data_t {
    #[doc = "< Size in bytes contained the auth_data buffer."]
    pub size: u16,
    #[doc = "< Additional data provided by Att key owner to be signed by the certification key"]
    pub auth_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sgx_ql_auth_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_auth_data_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_auth_data_t>(),
        2usize,
        concat!("Size of: ", stringify!(sgx_ql_auth_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_auth_data_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_auth_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_auth_data_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_auth_data_t),
            "::",
            stringify!(auth_data)
        )
    );
}
#[doc = " Data that will be signed by the ECDSA described in the CERTIFICATION_* fields.\nThis will be SHA256 hashed along with the ECDSA PUBLIC KEY and put in\nQE3_REPORT.ReportData."]
#[repr(C, packed)]
pub struct sgx_ql_certification_data_t {
    #[doc = "< The type of certification key used to sign the QE3 Report and Att key hash (ECDSA_ID+Authentication Data)."]
    pub cert_key_type: u16,
    #[doc = "< Size of the data structure for the cert_key_type information."]
    pub size: u32,
    #[doc = "< Certification data associated with the cert_key_type"]
    pub certification_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sgx_ql_certification_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_certification_data_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_certification_data_t>(),
        6usize,
        concat!("Size of: ", stringify!(sgx_ql_certification_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_certification_data_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_certification_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cert_key_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_certification_data_t),
            "::",
            stringify!(cert_key_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_certification_data_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).certification_data) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_certification_data_t),
            "::",
            stringify!(certification_data)
        )
    );
}
#[doc = " The SGX_QL_SGX_QL_ALG_ECDSA_P256 specific data structure.  Appears in the signature_data[] of the sgx_quote3_t\n  structure."]
#[repr(C, packed)]
pub struct sgx_ql_ecdsa_sig_data_t {
    #[doc = "< Signature over the Quote using the ECDSA Att key. Big Endian."]
    pub sig: [u8; 64usize],
    #[doc = "< ECDSA Att Public Key.  Hash in QE3Report.ReportData.  Big Endian"]
    pub attest_pub_key: [u8; 64usize],
    #[doc = "< QE3 Report of the QE when the Att key was generated.  The ReportData will contain the ECDSA_ID"]
    pub qe_report: sgx_report_body_t,
    #[doc = "< Signature of QE Report using the Certification Key (PCK for root signing). Big Endian"]
    pub qe_report_sig: [u8; 64usize],
    #[doc = "< Place holder for both the auth_data_t and certification_data_t.  Concatenated in that order."]
    pub auth_certification_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sgx_ql_ecdsa_sig_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_ecdsa_sig_data_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_ecdsa_sig_data_t>(),
        576usize,
        concat!("Size of: ", stringify!(sgx_ql_ecdsa_sig_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_ecdsa_sig_data_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_ecdsa_sig_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ecdsa_sig_data_t),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attest_pub_key) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ecdsa_sig_data_t),
            "::",
            stringify!(attest_pub_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_report) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ecdsa_sig_data_t),
            "::",
            stringify!(qe_report)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_report_sig) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ecdsa_sig_data_t),
            "::",
            stringify!(qe_report_sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_certification_data) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_ecdsa_sig_data_t),
            "::",
            stringify!(auth_certification_data)
        )
    );
}
#[doc = " The quote header.  It is designed to compatible with earlier versions of the quote."]
#[repr(C, packed)]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct sgx_quote_header_t {
    #[doc = "< 0:  The version this quote structure."]
    pub version: u16,
    #[doc = "< 2:  sgx_attestation_algorithm_id_t.  Describes the type of signature in the signature_data[] field."]
    pub att_key_type: u16,
    #[doc = "< 4:  Optionally stores additional data associated with the att_key_type."]
    pub att_key_data_0: u32,
    #[doc = "< 8:  The ISV_SVN of the Quoting Enclave when the quote was generated."]
    pub qe_svn: sgx_isv_svn_t,
    #[doc = "< 10: The ISV_SVN of the PCE when the quote was generated."]
    pub pce_svn: sgx_isv_svn_t,
    #[doc = "< 12: Unique identifier of QE Vendor."]
    pub vendor_id: [u8; 16usize],
    #[doc = "< 28: Custom attestation key owner data."]
    pub user_data: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_sgx_quote_header_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_quote_header_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_quote_header_t>(),
        48usize,
        concat!("Size of: ", stringify!(sgx_quote_header_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_quote_header_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_quote_header_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_header_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).att_key_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_header_t),
            "::",
            stringify!(att_key_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).att_key_data_0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_header_t),
            "::",
            stringify!(att_key_data_0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_svn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_header_t),
            "::",
            stringify!(qe_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pce_svn) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_header_t),
            "::",
            stringify!(pce_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vendor_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_header_t),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_header_t),
            "::",
            stringify!(user_data)
        )
    );
}
#[doc = " The generic quote data structure.  This is the common part of the quote.  The signature_data[] contains the signature and supporting\n  information of the key used to sign the quote and the contents depend on the sgx_quote_sign_type_t value."]
#[repr(C, packed)]
pub struct sgx_quote3_t {
    #[doc = "< 0:   The quote header."]
    pub header: sgx_quote_header_t,
    #[doc = "< 48: The REPORT of the app that is attesting remotely."]
    pub report_body: sgx_report_body_t,
    #[doc = "< 432: The length of the signature_data.  Varies depending on the type of sign_type."]
    pub signature_data_len: u32,
    #[doc = "< 436: Contains the variable length containing the quote signature and support data for the signature."]
    pub signature_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sgx_quote3_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_quote3_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_quote3_t>(),
        436usize,
        concat!("Size of: ", stringify!(sgx_quote3_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_quote3_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_quote3_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote3_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).report_body) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote3_t),
            "::",
            stringify!(report_body)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature_data_len) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote3_t),
            "::",
            stringify!(signature_data_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature_data) as usize - ptr as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote3_t),
            "::",
            stringify!(signature_data)
        )
    );
}
#[doc = " Describes the algorithm parameters needed to generate the given algorithm's signature.  Used for quote generation\n  APIs."]
#[repr(C, packed)]
pub struct sgx_ql_att_key_id_param_t {
    #[doc = "< Size of additional attestation key information.  0 is valid."]
    pub algorithm_param_size: u32,
    #[doc = "< Additional attestation algorithm information.For example, SigRL for EPID."]
    pub algorithm_param: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sgx_ql_att_key_id_param_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_att_key_id_param_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_att_key_id_param_t>(),
        4usize,
        concat!("Size of: ", stringify!(sgx_ql_att_key_id_param_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_att_key_id_param_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_att_key_id_param_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).algorithm_param_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_param_t),
            "::",
            stringify!(algorithm_param_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).algorithm_param) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_param_t),
            "::",
            stringify!(algorithm_param)
        )
    );
}
#[doc = " The full data structure passed to the platform by the verifier. It will list all of the attestation algorithms and\n  QE's supported by the verifier"]
#[repr(C)]
pub struct sgx_ql_att_id_list_t {
    #[doc = "< Header for the attestation key ID list provided by the quote verifier."]
    pub header: sgx_ql_att_key_id_list_header_t,
    #[doc = "< Place holder for the extended attestation ID list."]
    pub ext_id_list: __IncompleteArrayField<sgx_att_key_id_ext_t>,
}
#[test]
fn bindgen_test_layout_sgx_ql_att_id_list_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_att_id_list_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_att_id_list_t>(),
        8usize,
        concat!("Size of: ", stringify!(sgx_ql_att_id_list_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_att_id_list_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_att_id_list_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_id_list_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_id_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_id_list_t),
            "::",
            stringify!(ext_id_list)
        )
    );
}
#[repr(C, packed)]
#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]
pub struct sgx_ql_qe_report_info_t {
    pub nonce: sgx_quote_nonce_t,
    pub app_enclave_target_info: sgx_target_info_t,
    pub qe_report: sgx_report_t,
}
#[test]
fn bindgen_test_layout_sgx_ql_qe_report_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_qe_report_info_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_qe_report_info_t>(),
        960usize,
        concat!("Size of: ", stringify!(sgx_ql_qe_report_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_qe_report_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_qe_report_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nonce) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qe_report_info_t),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).app_enclave_target_info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qe_report_info_t),
            "::",
            stringify!(app_enclave_target_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_report) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qe_report_info_t),
            "::",
            stringify!(qe_report)
        )
    );
}
impl sgx_ql_qv_result_t {
    #[doc = "< The Quote verification passed and is at the latest TCB level"]
    pub const SGX_QL_QV_RESULT_OK: sgx_ql_qv_result_t = sgx_ql_qv_result_t(0);
}
impl sgx_ql_qv_result_t {
    pub const SGX_QL_QV_RESULT_MIN: sgx_ql_qv_result_t = sgx_ql_qv_result_t(40961);
}
impl sgx_ql_qv_result_t {
    #[doc = "< The Quote verification passed and the platform is patched to\n< the latest TCB level but additional configuration of the SGX\n< platform may be needed"]
    pub const SGX_QL_QV_RESULT_CONFIG_NEEDED: sgx_ql_qv_result_t = sgx_ql_qv_result_t(40961);
}
impl sgx_ql_qv_result_t {
    #[doc = "< The Quote is good but TCB level of the platform is out of date.\n< The platform needs patching to be at the latest TCB level"]
    pub const SGX_QL_QV_RESULT_OUT_OF_DATE: sgx_ql_qv_result_t = sgx_ql_qv_result_t(40962);
}
impl sgx_ql_qv_result_t {
    #[doc = "< The Quote is good but the TCB level of the platform is out of\n< date and additional configuration of the SGX Platform at its\n< current patching level may be needed. The platform needs\n< patching to be at the latest TCB level"]
    pub const SGX_QL_QV_RESULT_OUT_OF_DATE_CONFIG_NEEDED: sgx_ql_qv_result_t =
        sgx_ql_qv_result_t(40963);
}
impl sgx_ql_qv_result_t {
    #[doc = "< The signature over the application report is invalid"]
    pub const SGX_QL_QV_RESULT_INVALID_SIGNATURE: sgx_ql_qv_result_t = sgx_ql_qv_result_t(40964);
}
impl sgx_ql_qv_result_t {
    #[doc = "< The attestation key or platform has been revoked"]
    pub const SGX_QL_QV_RESULT_REVOKED: sgx_ql_qv_result_t = sgx_ql_qv_result_t(40965);
}
impl sgx_ql_qv_result_t {
    #[doc = "< The Quote verification failed due to an error in one of the input"]
    pub const SGX_QL_QV_RESULT_UNSPECIFIED: sgx_ql_qv_result_t = sgx_ql_qv_result_t(40966);
}
impl sgx_ql_qv_result_t {
    #[doc = "< The TCB level of the platform is up to date, but SGX SW Hardening\n< is needed"]
    pub const SGX_QL_QV_RESULT_SW_HARDENING_NEEDED: sgx_ql_qv_result_t = sgx_ql_qv_result_t(40967);
}
impl sgx_ql_qv_result_t {
    #[doc = "< The TCB level of the platform is up to date, but additional\n< configuration of the platform at its current patching level\n< may be needed. Moreove, SGX SW Hardening is also needed"]
    pub const SGX_QL_QV_RESULT_CONFIG_AND_SW_HARDENING_NEEDED: sgx_ql_qv_result_t =
        sgx_ql_qv_result_t(40968);
}
impl sgx_ql_qv_result_t {
    #[doc = "< For TDX only. All components in the TD’s TCB are latest, including the\n< TD preserving loaded TDX, but the TD was launched and ran for some time\n< with out-of-date TDX Module. Relaunching or re-provisioning your TD is advised"]
    pub const SGX_QL_QV_RESULT_TD_RELAUNCH_ADVISED: sgx_ql_qv_result_t = sgx_ql_qv_result_t(40969);
}
impl sgx_ql_qv_result_t {
    #[doc = "< Indicate max result to allow better translation"]
    pub const SGX_QL_QV_RESULT_MAX: sgx_ql_qv_result_t = sgx_ql_qv_result_t(41215);
}
#[repr(transparent)]
#[doc = " Contains the possible values of the quote verification result."]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct sgx_ql_qv_result_t(pub core::ffi::c_uint);
impl pck_cert_flag_enum_t {
    pub const PCK_FLAG_FALSE: pck_cert_flag_enum_t = pck_cert_flag_enum_t(0);
}
impl pck_cert_flag_enum_t {
    pub const PCK_FLAG_TRUE: pck_cert_flag_enum_t = pck_cert_flag_enum_t(1);
}
impl pck_cert_flag_enum_t {
    pub const PCK_FLAG_UNDEFINED: pck_cert_flag_enum_t = pck_cert_flag_enum_t(2);
}
#[repr(transparent)]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct pck_cert_flag_enum_t(pub core::ffi::c_uint);
#[doc = " Contains data that will allow an alternative quote verification policy."]
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_qv_supplemental_t {
    pub __bindgen_anon_1: sgx_ql_qv_supplemental_t__bindgen_ty_1_t,
    #[doc = "< Earliest issue date of all the collateral (UTC)"]
    pub earliest_issue_date: time_t,
    #[doc = "< Latest issue date of all the collateral (UTC)"]
    pub latest_issue_date: time_t,
    #[doc = "< Earliest expiration date of all the collateral (UTC)"]
    pub earliest_expiration_date: time_t,
    #[doc = "< The SGX TCB of the platform that generated the quote is not vulnerable\n< to any Security Advisory with an SGX TCB impact released on or before this date.\n< See Intel Security Center Advisories"]
    pub tcb_level_date_tag: time_t,
    #[doc = "< CRL Num from PCK Cert CRL"]
    pub pck_crl_num: u32,
    #[doc = "< CRL Num from Root CA CRL"]
    pub root_ca_crl_num: u32,
    #[doc = "< Lower number of the TCBInfo and QEIdentity"]
    pub tcb_eval_ref_num: u32,
    #[doc = "< ID of the collateral's root signer (hash of Root CA's public key SHA-384)"]
    pub root_key_id: [u8; 48usize],
    #[doc = "< PPID from remote platform.  Can be used for platform ownership checks"]
    pub pck_ppid: sgx_key_128bit_t,
    #[doc = "< CPUSVN of the remote platform's PCK Cert"]
    pub tcb_cpusvn: sgx_cpu_svn_t,
    #[doc = "< PCE_ISVNSVN of the remote platform's PCK Cert"]
    pub tcb_pce_isvsvn: sgx_isv_svn_t,
    #[doc = "< PCE_ID of the remote platform"]
    pub pce_id: u16,
    #[doc = "< 0x00000000: SGX or 0x00000081: TDX"]
    pub tee_type: u32,
    #[doc = "< Indicate the type of memory protection available on the platform, it should be one of\n< Standard (0), Scalable (1) and Scalable with Integrity (2)"]
    pub sgx_type: u8,
    #[doc = "< Value of Platform Instance ID, 16 bytes"]
    pub platform_instance_id: [u8; 16usize],
    #[doc = "< Indicate whether a platform can be extended with additional packages - via Package Add calls to SGX Registration Backend"]
    pub dynamic_platform: pck_cert_flag_enum_t,
    #[doc = "< Indicate whether platform root keys are cached by SGX Registration Backend"]
    pub cached_keys: pck_cert_flag_enum_t,
    #[doc = "< Indicate whether a plat form has SMT (simultaneous multithreading) enabled"]
    pub smt_enabled: pck_cert_flag_enum_t,
    #[doc = "< String of comma separated list of Security Advisory IDs"]
    pub sa_list: [core::ffi::c_char; 320usize],
    #[doc = "< Earliest issue date of QEIdentity (UTC)"]
    pub qe_iden_earliest_issue_date: time_t,
    #[doc = "< Latest issue date of QEIdentity (UTC)"]
    pub qe_iden_latest_issue_date: time_t,
    #[doc = "< Earliest expiration date of QEIdentity (UTC)"]
    pub qe_iden_earliest_expiration_date: time_t,
    #[doc = "< The SGX TCB of the platform that generated the quote is not vulnerable"]
    pub qe_iden_tcb_level_date_tag: time_t,
    #[doc = "< Lower number of the QEIdentity"]
    pub qe_iden_tcb_eval_ref_num: u32,
    pub qe_iden_status: sgx_ql_qv_result_t,
}
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_qv_supplemental_t__bindgen_ty_1_t {
    #[doc = "< 'version' is the backward compatible legacy representation"]
    pub version: __BindgenUnionField<u32>,
    pub __bindgen_anon_1:
        __BindgenUnionField<sgx_ql_qv_supplemental_t__bindgen_ty_1__bindgen_ty_1_t>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_qv_supplemental_t__bindgen_ty_1__bindgen_ty_1_t {
    #[doc = "< If this major version doesn't change, the size of the structure may change and new fields appended to the end but old minor version structure can still be 'cast'\n< If this major version does change, then the structure has been modified in a way that makes the older definitions non-backwards compatible. i.e. You cannot 'cast' older definitions"]
    pub major_version: u16,
    #[doc = "< If this version changes, new fields have been appended to the end of the previous minor version definition of the structure\n< Set to 1 to support SA_List.  Set to 0 to support everything except the SA List"]
    pub minor_version: u16,
}
#[test]
fn bindgen_test_layout_sgx_ql_qv_supplemental_t__bindgen_ty_1__bindgen_ty_1_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_qv_supplemental_t__bindgen_ty_1__bindgen_ty_1_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_qv_supplemental_t__bindgen_ty_1__bindgen_ty_1_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sgx_ql_qv_supplemental_t__bindgen_ty_1__bindgen_ty_1_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_qv_supplemental_t__bindgen_ty_1__bindgen_ty_1_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(sgx_ql_qv_supplemental_t__bindgen_ty_1__bindgen_ty_1_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).major_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t__bindgen_ty_1__bindgen_ty_1_t),
            "::",
            stringify!(major_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor_version) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t__bindgen_ty_1__bindgen_ty_1_t),
            "::",
            stringify!(minor_version)
        )
    );
}
#[test]
fn bindgen_test_layout_sgx_ql_qv_supplemental_t__bindgen_ty_1_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_qv_supplemental_t__bindgen_ty_1_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_qv_supplemental_t__bindgen_ty_1_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sgx_ql_qv_supplemental_t__bindgen_ty_1_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_qv_supplemental_t__bindgen_ty_1_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(sgx_ql_qv_supplemental_t__bindgen_ty_1_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t__bindgen_ty_1_t),
            "::",
            stringify!(version)
        )
    );
}
#[test]
fn bindgen_test_layout_sgx_ql_qv_supplemental_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_qv_supplemental_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_qv_supplemental_t>(),
        536usize,
        concat!("Size of: ", stringify!(sgx_ql_qv_supplemental_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_qv_supplemental_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sgx_ql_qv_supplemental_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).earliest_issue_date) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(earliest_issue_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latest_issue_date) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(latest_issue_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).earliest_expiration_date) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(earliest_expiration_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcb_level_date_tag) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(tcb_level_date_tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pck_crl_num) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(pck_crl_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root_ca_crl_num) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(root_ca_crl_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcb_eval_ref_num) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(tcb_eval_ref_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root_key_id) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(root_key_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pck_ppid) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(pck_ppid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcb_cpusvn) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(tcb_cpusvn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcb_pce_isvsvn) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(tcb_pce_isvsvn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pce_id) as usize - ptr as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(pce_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tee_type) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(tee_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sgx_type) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(sgx_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).platform_instance_id) as usize - ptr as usize },
        141usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(platform_instance_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dynamic_platform) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(dynamic_platform)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cached_keys) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(cached_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).smt_enabled) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(smt_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sa_list) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(sa_list)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).qe_iden_earliest_issue_date) as usize - ptr as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(qe_iden_earliest_issue_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_iden_latest_issue_date) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(qe_iden_latest_issue_date)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).qe_iden_earliest_expiration_date) as usize - ptr as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(qe_iden_earliest_expiration_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_iden_tcb_level_date_tag) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(qe_iden_tcb_level_date_tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_iden_tcb_eval_ref_num) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(qe_iden_tcb_eval_ref_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_iden_status) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_qv_supplemental_t),
            "::",
            stringify!(qe_iden_status)
        )
    );
}
