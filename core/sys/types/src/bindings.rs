/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const SGX_FLAGS_INITTED: u32 = 1;
pub const SGX_FLAGS_DEBUG: u32 = 2;
pub const SGX_FLAGS_MODE64BIT: u32 = 4;
pub const SGX_FLAGS_PROVISION_KEY: u32 = 16;
pub const SGX_FLAGS_EINITTOKEN_KEY: u32 = 32;
pub const SGX_FLAGS_KSS: u32 = 128;
pub const SGX_FLAGS_AEX_NOTIFY: u32 = 1024;
pub const SGX_FLAGS_NON_CHECK_BITS: u64 = 71776119061217280;
pub const SGX_XFRM_LEGACY: u32 = 3;
pub const SGX_XFRM_AVX: u32 = 6;
pub const SGX_XFRM_AVX512: u32 = 230;
pub const SGX_XFRM_MPX: u32 = 24;
pub const SGX_XFRM_PKRU: u32 = 512;
pub const SGX_XFRM_AMX: u32 = 393216;
pub const SGX_XFRM_RESERVED: i32 = -393960;
pub const SGX_KEYSELECT_EINITTOKEN: u16 = 0;
pub const SGX_KEYSELECT_PROVISION: u16 = 1;
pub const SGX_KEYSELECT_PROVISION_SEAL: u16 = 2;
pub const SGX_KEYSELECT_REPORT: u16 = 3;
pub const SGX_KEYSELECT_SEAL: u16 = 4;
pub const SGX_KEYPOLICY_MRENCLAVE: u16 = 1;
pub const SGX_KEYPOLICY_MRSIGNER: u16 = 2;
pub const SGX_KEYPOLICY_NOISVPRODID: u16 = 4;
pub const SGX_KEYPOLICY_CONFIGID: u16 = 8;
pub const SGX_KEYPOLICY_ISVFAMILYID: u16 = 16;
pub const SGX_KEYPOLICY_ISVEXTPRODID: u16 = 32;
pub const SGX_KEYID_SIZE: usize = 32;
pub const SGX_CPUSVN_SIZE: usize = 16;
pub const SGX_CONFIGID_SIZE: usize = 64;
pub const SGX_KEY_REQUEST_RESERVED2_BYTES: usize = 434;
pub const SGX_HASH_SIZE: usize = 32;
pub const SGX_MAC_SIZE: usize = 16;
pub const SGX_REPORT_DATA_SIZE: usize = 64;
pub const SGX_ISVEXT_PROD_ID_SIZE: usize = 16;
pub const SGX_ISV_FAMILY_ID_SIZE: usize = 16;
pub const SGX_TARGET_INFO_RESERVED1_BYTES: usize = 2;
pub const SGX_TARGET_INFO_RESERVED2_BYTES: usize = 8;
pub const SGX_TARGET_INFO_RESERVED3_BYTES: usize = 384;
pub const SGX_REPORT_BODY_RESERVED1_BYTES: usize = 12;
pub const SGX_REPORT_BODY_RESERVED2_BYTES: usize = 32;
pub const SGX_REPORT_BODY_RESERVED3_BYTES: usize = 32;
pub const SGX_REPORT_BODY_RESERVED4_BYTES: usize = 42;
pub const SGX_PLATFORM_INFO_SIZE: usize = 101;
impl sgx_status_t {
    pub const SGX_SUCCESS: sgx_status_t = sgx_status_t(0);
}
impl sgx_status_t {
    pub const SGX_ERROR_UNEXPECTED: sgx_status_t = sgx_status_t(1);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_PARAMETER: sgx_status_t = sgx_status_t(2);
}
impl sgx_status_t {
    pub const SGX_ERROR_OUT_OF_MEMORY: sgx_status_t = sgx_status_t(3);
}
impl sgx_status_t {
    pub const SGX_ERROR_ENCLAVE_LOST: sgx_status_t = sgx_status_t(4);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_STATE: sgx_status_t = sgx_status_t(5);
}
impl sgx_status_t {
    pub const SGX_ERROR_FEATURE_NOT_SUPPORTED: sgx_status_t = sgx_status_t(8);
}
impl sgx_status_t {
    pub const SGX_PTHREAD_EXIT: sgx_status_t = sgx_status_t(9);
}
impl sgx_status_t {
    pub const SGX_ERROR_MEMORY_MAP_FAILURE: sgx_status_t = sgx_status_t(10);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_FUNCTION: sgx_status_t = sgx_status_t(4097);
}
impl sgx_status_t {
    pub const SGX_ERROR_OUT_OF_TCS: sgx_status_t = sgx_status_t(4099);
}
impl sgx_status_t {
    pub const SGX_ERROR_ENCLAVE_CRASHED: sgx_status_t = sgx_status_t(4102);
}
impl sgx_status_t {
    pub const SGX_ERROR_ECALL_NOT_ALLOWED: sgx_status_t = sgx_status_t(4103);
}
impl sgx_status_t {
    pub const SGX_ERROR_OCALL_NOT_ALLOWED: sgx_status_t = sgx_status_t(4104);
}
impl sgx_status_t {
    pub const SGX_ERROR_STACK_OVERRUN: sgx_status_t = sgx_status_t(4105);
}
impl sgx_status_t {
    pub const SGX_ERROR_UNDEFINED_SYMBOL: sgx_status_t = sgx_status_t(8192);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_ENCLAVE: sgx_status_t = sgx_status_t(8193);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_ENCLAVE_ID: sgx_status_t = sgx_status_t(8194);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_SIGNATURE: sgx_status_t = sgx_status_t(8195);
}
impl sgx_status_t {
    pub const SGX_ERROR_NDEBUG_ENCLAVE: sgx_status_t = sgx_status_t(8196);
}
impl sgx_status_t {
    pub const SGX_ERROR_OUT_OF_EPC: sgx_status_t = sgx_status_t(8197);
}
impl sgx_status_t {
    pub const SGX_ERROR_NO_DEVICE: sgx_status_t = sgx_status_t(8198);
}
impl sgx_status_t {
    pub const SGX_ERROR_MEMORY_MAP_CONFLICT: sgx_status_t = sgx_status_t(8199);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_METADATA: sgx_status_t = sgx_status_t(8201);
}
impl sgx_status_t {
    pub const SGX_ERROR_DEVICE_BUSY: sgx_status_t = sgx_status_t(8204);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_VERSION: sgx_status_t = sgx_status_t(8205);
}
impl sgx_status_t {
    pub const SGX_ERROR_MODE_INCOMPATIBLE: sgx_status_t = sgx_status_t(8206);
}
impl sgx_status_t {
    pub const SGX_ERROR_ENCLAVE_FILE_ACCESS: sgx_status_t = sgx_status_t(8207);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_MISC: sgx_status_t = sgx_status_t(8208);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_LAUNCH_TOKEN: sgx_status_t = sgx_status_t(8209);
}
impl sgx_status_t {
    pub const SGX_ERROR_MAC_MISMATCH: sgx_status_t = sgx_status_t(12289);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_ATTRIBUTE: sgx_status_t = sgx_status_t(12290);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_CPUSVN: sgx_status_t = sgx_status_t(12291);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_ISVSVN: sgx_status_t = sgx_status_t(12292);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_KEYNAME: sgx_status_t = sgx_status_t(12293);
}
impl sgx_status_t {
    pub const SGX_ERROR_SERVICE_UNAVAILABLE: sgx_status_t = sgx_status_t(16385);
}
impl sgx_status_t {
    pub const SGX_ERROR_SERVICE_TIMEOUT: sgx_status_t = sgx_status_t(16386);
}
impl sgx_status_t {
    pub const SGX_ERROR_AE_INVALID_EPIDBLOB: sgx_status_t = sgx_status_t(16387);
}
impl sgx_status_t {
    pub const SGX_ERROR_SERVICE_INVALID_PRIVILEGE: sgx_status_t = sgx_status_t(16388);
}
impl sgx_status_t {
    pub const SGX_ERROR_EPID_MEMBER_REVOKED: sgx_status_t = sgx_status_t(16389);
}
impl sgx_status_t {
    pub const SGX_ERROR_UPDATE_NEEDED: sgx_status_t = sgx_status_t(16390);
}
impl sgx_status_t {
    pub const SGX_ERROR_NETWORK_FAILURE: sgx_status_t = sgx_status_t(16391);
}
impl sgx_status_t {
    pub const SGX_ERROR_AE_SESSION_INVALID: sgx_status_t = sgx_status_t(16392);
}
impl sgx_status_t {
    pub const SGX_ERROR_BUSY: sgx_status_t = sgx_status_t(16394);
}
impl sgx_status_t {
    pub const SGX_ERROR_MC_NOT_FOUND: sgx_status_t = sgx_status_t(16396);
}
impl sgx_status_t {
    pub const SGX_ERROR_MC_NO_ACCESS_RIGHT: sgx_status_t = sgx_status_t(16397);
}
impl sgx_status_t {
    pub const SGX_ERROR_MC_USED_UP: sgx_status_t = sgx_status_t(16398);
}
impl sgx_status_t {
    pub const SGX_ERROR_MC_OVER_QUOTA: sgx_status_t = sgx_status_t(16399);
}
impl sgx_status_t {
    pub const SGX_ERROR_KDF_MISMATCH: sgx_status_t = sgx_status_t(16401);
}
impl sgx_status_t {
    pub const SGX_ERROR_UNRECOGNIZED_PLATFORM: sgx_status_t = sgx_status_t(16402);
}
impl sgx_status_t {
    pub const SGX_ERROR_UNSUPPORTED_CONFIG: sgx_status_t = sgx_status_t(16403);
}
impl sgx_status_t {
    pub const SGX_ERROR_NO_PRIVILEGE: sgx_status_t = sgx_status_t(20482);
}
impl sgx_status_t {
    pub const SGX_ERROR_PCL_ENCRYPTED: sgx_status_t = sgx_status_t(24577);
}
impl sgx_status_t {
    pub const SGX_ERROR_PCL_NOT_ENCRYPTED: sgx_status_t = sgx_status_t(24578);
}
impl sgx_status_t {
    pub const SGX_ERROR_PCL_MAC_MISMATCH: sgx_status_t = sgx_status_t(24579);
}
impl sgx_status_t {
    pub const SGX_ERROR_PCL_SHA_MISMATCH: sgx_status_t = sgx_status_t(24580);
}
impl sgx_status_t {
    pub const SGX_ERROR_PCL_GUID_MISMATCH: sgx_status_t = sgx_status_t(24581);
}
impl sgx_status_t {
    pub const SGX_ERROR_FILE_BAD_STATUS: sgx_status_t = sgx_status_t(28673);
}
impl sgx_status_t {
    pub const SGX_ERROR_FILE_NO_KEY_ID: sgx_status_t = sgx_status_t(28674);
}
impl sgx_status_t {
    pub const SGX_ERROR_FILE_NAME_MISMATCH: sgx_status_t = sgx_status_t(28675);
}
impl sgx_status_t {
    pub const SGX_ERROR_FILE_NOT_SGX_FILE: sgx_status_t = sgx_status_t(28676);
}
impl sgx_status_t {
    pub const SGX_ERROR_FILE_CANT_OPEN_RECOVERY_FILE: sgx_status_t = sgx_status_t(28677);
}
impl sgx_status_t {
    pub const SGX_ERROR_FILE_CANT_WRITE_RECOVERY_FILE: sgx_status_t = sgx_status_t(28678);
}
impl sgx_status_t {
    pub const SGX_ERROR_FILE_RECOVERY_NEEDED: sgx_status_t = sgx_status_t(28679);
}
impl sgx_status_t {
    pub const SGX_ERROR_FILE_FLUSH_FAILED: sgx_status_t = sgx_status_t(28680);
}
impl sgx_status_t {
    pub const SGX_ERROR_FILE_CLOSE_FAILED: sgx_status_t = sgx_status_t(28681);
}
impl sgx_status_t {
    pub const SGX_ERROR_UNSUPPORTED_ATT_KEY_ID: sgx_status_t = sgx_status_t(32769);
}
impl sgx_status_t {
    pub const SGX_ERROR_ATT_KEY_CERTIFICATION_FAILURE: sgx_status_t = sgx_status_t(32770);
}
impl sgx_status_t {
    pub const SGX_ERROR_ATT_KEY_UNINITIALIZED: sgx_status_t = sgx_status_t(32771);
}
impl sgx_status_t {
    pub const SGX_ERROR_INVALID_ATT_KEY_CERT_DATA: sgx_status_t = sgx_status_t(32772);
}
impl sgx_status_t {
    pub const SGX_ERROR_PLATFORM_CERT_UNAVAILABLE: sgx_status_t = sgx_status_t(32773);
}
impl sgx_status_t {
    pub const SGX_ERROR_TLS_X509_INVALID_EXTENSION: sgx_status_t = sgx_status_t(36865);
}
impl sgx_status_t {
    pub const SGX_INTERNAL_ERROR_ENCLAVE_CREATE_INTERRUPTED: sgx_status_t = sgx_status_t(61441);
}
#[repr(transparent)]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct sgx_status_t(pub core::ffi::c_uint);
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct sgx_attributes_t {
    pub flags: u64,
    pub xfrm: u64,
}
#[test]
fn bindgen_test_layout_sgx_attributes_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_attributes_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_attributes_t>(),
        16usize,
        concat!("Size of: ", stringify!(sgx_attributes_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_attributes_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sgx_attributes_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_attributes_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xfrm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_attributes_t),
            "::",
            stringify!(xfrm)
        )
    );
}
pub type sgx_misc_select_t = u32;
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_misc_attribute_t {
    pub secs_attr: sgx_attributes_t,
    pub misc_select: sgx_misc_select_t,
}
#[test]
fn bindgen_test_layout_sgx_misc_attribute_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_misc_attribute_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_misc_attribute_t>(),
        24usize,
        concat!("Size of: ", stringify!(sgx_misc_attribute_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_misc_attribute_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sgx_misc_attribute_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).secs_attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_misc_attribute_t),
            "::",
            stringify!(secs_attr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).misc_select) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_misc_attribute_t),
            "::",
            stringify!(misc_select)
        )
    );
}
pub type sgx_key_128bit_t = [u8; 16usize];
pub type sgx_isv_svn_t = u16;
pub type sgx_config_svn_t = u16;
pub type sgx_config_id_t = [u8; 64usize];
#[repr(C)]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct sgx_cpu_svn_t {
    pub svn: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sgx_cpu_svn_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_cpu_svn_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_cpu_svn_t>(),
        16usize,
        concat!("Size of: ", stringify!(sgx_cpu_svn_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_cpu_svn_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_cpu_svn_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).svn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_cpu_svn_t),
            "::",
            stringify!(svn)
        )
    );
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct sgx_key_id_t {
    pub id: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_sgx_key_id_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_key_id_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_key_id_t>(),
        32usize,
        concat!("Size of: ", stringify!(sgx_key_id_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_key_id_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_key_id_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_key_id_t),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_key_request_t {
    pub key_name: u16,
    pub key_policy: u16,
    pub isv_svn: sgx_isv_svn_t,
    pub reserved1: u16,
    pub cpu_svn: sgx_cpu_svn_t,
    pub attribute_mask: sgx_attributes_t,
    pub key_id: sgx_key_id_t,
    pub misc_mask: sgx_misc_select_t,
    pub config_svn: sgx_config_svn_t,
    pub reserved2: [u8; 434usize],
}
#[test]
fn bindgen_test_layout_sgx_key_request_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_key_request_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_key_request_t>(),
        512usize,
        concat!("Size of: ", stringify!(sgx_key_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_key_request_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sgx_key_request_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_key_request_t),
            "::",
            stringify!(key_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_policy) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_key_request_t),
            "::",
            stringify!(key_policy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).isv_svn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_key_request_t),
            "::",
            stringify!(isv_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_key_request_t),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_svn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_key_request_t),
            "::",
            stringify!(cpu_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attribute_mask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_key_request_t),
            "::",
            stringify!(attribute_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_key_request_t),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).misc_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_key_request_t),
            "::",
            stringify!(misc_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_svn) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_key_request_t),
            "::",
            stringify!(config_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_key_request_t),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct sgx_measurement_t {
    pub m: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_sgx_measurement_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_measurement_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_measurement_t>(),
        32usize,
        concat!("Size of: ", stringify!(sgx_measurement_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_measurement_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_measurement_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_measurement_t),
            "::",
            stringify!(m)
        )
    );
}
pub type sgx_mac_t = [u8; 16usize];
pub type sgx_prod_id_t = u16;
pub type sgx_isvext_prod_id_t = [u8; 16usize];
pub type sgx_isvfamily_id_t = [u8; 16usize];
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct sgx_report_t {
    pub body: sgx_report_body_t,
    pub key_id: sgx_key_id_t,
    pub mac: sgx_mac_t,
}
#[test]
fn bindgen_test_layout_sgx_report_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_report_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_report_t>(),
        432usize,
        concat!("Size of: ", stringify!(sgx_report_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_report_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sgx_report_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_report_t),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_id) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_report_t),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_report_t),
            "::",
            stringify!(mac)
        )
    );
}
pub type sgx_epid_group_id_t = [u8; 4usize];
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_spid_t {
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sgx_spid_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_spid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_spid_t>(),
        16usize,
        concat!("Size of: ", stringify!(sgx_spid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_spid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_spid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_spid_t),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Clone, Debug, Default, Eq, Hash, PartialEq)]
pub struct sgx_basename_t {
    pub name: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_sgx_basename_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_basename_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_basename_t>(),
        32usize,
        concat!("Size of: ", stringify!(sgx_basename_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_basename_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_basename_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_basename_t),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct sgx_quote_nonce_t {
    pub rand: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sgx_quote_nonce_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_quote_nonce_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_quote_nonce_t>(),
        16usize,
        concat!("Size of: ", stringify!(sgx_quote_nonce_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_quote_nonce_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_quote_nonce_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_nonce_t),
            "::",
            stringify!(rand)
        )
    );
}
impl sgx_quote_sign_type_t {
    pub const SGX_UNLINKABLE_SIGNATURE: sgx_quote_sign_type_t = sgx_quote_sign_type_t(0);
}
impl sgx_quote_sign_type_t {
    pub const SGX_LINKABLE_SIGNATURE: sgx_quote_sign_type_t = sgx_quote_sign_type_t(1);
}
#[repr(transparent)]
#[derive(Clone, Hash, PartialEq, Eq, Copy, Debug)]
pub struct sgx_quote_sign_type_t(pub core::ffi::c_uint);
#[repr(C, packed)]
pub struct sgx_quote_t {
    pub version: u16,
    pub sign_type: u16,
    pub epid_group_id: sgx_epid_group_id_t,
    pub qe_svn: sgx_isv_svn_t,
    pub pce_svn: sgx_isv_svn_t,
    pub xeid: u32,
    pub basename: sgx_basename_t,
    pub report_body: sgx_report_body_t,
    pub signature_len: u32,
    pub signature: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sgx_quote_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_quote_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_quote_t>(),
        436usize,
        concat!("Size of: ", stringify!(sgx_quote_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_quote_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_quote_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sign_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_t),
            "::",
            stringify!(sign_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).epid_group_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_t),
            "::",
            stringify!(epid_group_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_svn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_t),
            "::",
            stringify!(qe_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pce_svn) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_t),
            "::",
            stringify!(pce_svn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xeid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_t),
            "::",
            stringify!(xeid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).basename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_t),
            "::",
            stringify!(basename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).report_body) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_t),
            "::",
            stringify!(report_body)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature_len) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_t),
            "::",
            stringify!(signature_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_quote_t),
            "::",
            stringify!(signature)
        )
    );
}
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_platform_info_t {
    pub platform_info: [u8; 101usize],
}
#[test]
fn bindgen_test_layout_sgx_platform_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_platform_info_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_platform_info_t>(),
        101usize,
        concat!("Size of: ", stringify!(sgx_platform_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_platform_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_platform_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).platform_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_platform_info_t),
            "::",
            stringify!(platform_info)
        )
    );
}
#[repr(C, packed)]
#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]
pub struct sgx_update_info_bit_t {
    pub ucodeUpdate: core::ffi::c_int,
    pub csmeFwUpdate: core::ffi::c_int,
    pub pswUpdate: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_sgx_update_info_bit_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_update_info_bit_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_update_info_bit_t>(),
        12usize,
        concat!("Size of: ", stringify!(sgx_update_info_bit_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_update_info_bit_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_update_info_bit_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ucodeUpdate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_update_info_bit_t),
            "::",
            stringify!(ucodeUpdate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).csmeFwUpdate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_update_info_bit_t),
            "::",
            stringify!(csmeFwUpdate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pswUpdate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_update_info_bit_t),
            "::",
            stringify!(pswUpdate)
        )
    );
}
#[repr(C)]
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct sgx_att_key_id_t {
    pub att_key_id: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_sgx_att_key_id_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_att_key_id_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_att_key_id_t>(),
        256usize,
        concat!("Size of: ", stringify!(sgx_att_key_id_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_att_key_id_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_att_key_id_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).att_key_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_att_key_id_t),
            "::",
            stringify!(att_key_id)
        )
    );
}
#[doc = " Describes a single attestation key.  Contains both QE identity and the attestation algorithm ID."]
#[repr(C, packed)]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct sgx_ql_att_key_id_t {
    #[doc = "< Structure ID"]
    pub id: u16,
    #[doc = "< Structure version"]
    pub version: u16,
    #[doc = "< Number of valid bytes in MRSIGNER."]
    pub mrsigner_length: u16,
    #[doc = "< SHA256 or SHA384 hash of the Public key that signed the QE.\n< The lower bytes contain MRSIGNER.  Bytes beyond mrsigner_length '0'"]
    pub mrsigner: [u8; 48usize],
    #[doc = "< Legacy Product ID of the QE"]
    pub prod_id: u32,
    #[doc = "< Extended Product ID or the QE. All 0's for legacy format enclaves."]
    pub extended_prod_id: [u8; 16usize],
    #[doc = "< Config ID of the QE."]
    pub config_id: [u8; 64usize],
    #[doc = "< Family ID of the QE."]
    pub family_id: [u8; 16usize],
    #[doc = "< Identity of the attestation key algorithm."]
    pub algorithm_id: u32,
}
#[test]
fn bindgen_test_layout_sgx_ql_att_key_id_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_ql_att_key_id_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_ql_att_key_id_t>(),
        158usize,
        concat!("Size of: ", stringify!(sgx_ql_att_key_id_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_ql_att_key_id_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_ql_att_key_id_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mrsigner_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_t),
            "::",
            stringify!(mrsigner_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mrsigner) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_t),
            "::",
            stringify!(mrsigner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_id) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_t),
            "::",
            stringify!(prod_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extended_prod_id) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_t),
            "::",
            stringify!(extended_prod_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_id) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_t),
            "::",
            stringify!(config_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).family_id) as usize - ptr as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_t),
            "::",
            stringify!(family_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).algorithm_id) as usize - ptr as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_ql_att_key_id_t),
            "::",
            stringify!(algorithm_id)
        )
    );
}
#[doc = " Describes an extended attestation key.  Contains sgx_ql_att_key_id_t, spid and quote_type"]
#[repr(C, packed)]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub struct sgx_att_key_id_ext_t {
    pub base: sgx_ql_att_key_id_t,
    #[doc = "< Service Provider ID, should be 0s for ECDSA quote"]
    pub spid: [u8; 16usize],
    #[doc = "< For non-EPID quote, it should be 0\n< For EPID quote, it equals to sgx_quote_sign_type_t"]
    pub att_key_type: u16,
    #[doc = "< It should have the same size of sgx_att_key_id_t"]
    pub reserved: [u8; 80usize],
}
#[test]
fn bindgen_test_layout_sgx_att_key_id_ext_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_att_key_id_ext_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_att_key_id_ext_t>(),
        256usize,
        concat!("Size of: ", stringify!(sgx_att_key_id_ext_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_att_key_id_ext_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_att_key_id_ext_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_att_key_id_ext_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spid) as usize - ptr as usize },
        158usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_att_key_id_ext_t),
            "::",
            stringify!(spid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).att_key_type) as usize - ptr as usize },
        174usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_att_key_id_ext_t),
            "::",
            stringify!(att_key_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_att_key_id_ext_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]
pub struct sgx_qe_report_info_t {
    pub nonce: sgx_quote_nonce_t,
    pub app_enclave_target_info: sgx_target_info_t,
    pub qe_report: sgx_report_t,
}
#[test]
fn bindgen_test_layout_sgx_qe_report_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<sgx_qe_report_info_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sgx_qe_report_info_t>(),
        960usize,
        concat!("Size of: ", stringify!(sgx_qe_report_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sgx_qe_report_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sgx_qe_report_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nonce) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_qe_report_info_t),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).app_enclave_target_info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_qe_report_info_t),
            "::",
            stringify!(app_enclave_target_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qe_report) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(sgx_qe_report_info_t),
            "::",
            stringify!(qe_report)
        )
    );
}
